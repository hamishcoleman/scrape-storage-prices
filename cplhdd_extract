#!/usr/bin/env perl
use warnings;
use strict;
#
# Grab the hard drives data from CPL
#

# allow the libs to be in the bin dir
use FindBin;
use lib "$FindBin::RealBin/lib";
use lib "/home/hamish/s/bin/lib";

use HTML::TreeBuilder;
use IO::HTML;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

sub file2tree {
    my $file = shift;

    my $fh = html_file($file);
    return undef if (!$fh);

    my $tree = HTML::TreeBuilder->new;
    $tree->parse_file($fh);
    $tree->eof;
    $tree->elementify;

    return $tree;
}

sub default {
    my $data = shift;
    my $key = shift;
    my $val = shift;

    if (!defined($data->{$key})) {
        $data->{$key} = $val;
    }
}

sub normalise1product {
    my $data = shift;

    # Normalise the price field
    $data->{price} =~ s/^\$//;
    $data->{price} =~ s/,//;

    my $t = $data->{comment};

    my $table = {
        # rpm
        ' SSD ' => { rpm => 'SSD' },

        # form factor
        ' 2.5" '        => { form => '2.5"' },
        ' 3.5" '        => { form => '3.5"' },
        ' 2.5in( |$)'   => { form => '2.5"' },
        ' 3.5in '       => { form => '3.5"' },
        'M.2 2280'      => { form => 'M.2' },
        'PCIE M2'       => { form => 'M.2', interface => 'NVME' },
    };

    while (my ($re,$entry) = each(%{$table})) {
        if ($t =~ m/$re/i) {
            while (my ($k,$v) = each(%{$entry})) {
                if (defined($data->{$k})) {
                    die("Duplicate match $re $k");
                } else {
                    $data->{$k} = $v;
                }
            }
        }
    }

    if ($t =~ m/ (\d+)rpm/i) {
        $data->{rpm} = $1;
    } elsif ($t =~ m/ ([0-9][0-9.]+)k/i) {
        $data->{rpm} = $1 * 1000;
    }

    if ($t =~ m/ (\d+)tb( |,|$)/i) {
        $data->{gig} = $1 * 1000;
    } elsif ($t =~ m/ (\d+)gb( |,|$)/i) {
        $data->{gig} = $1;
    } elsif ($t =~ m/ (\d+) gb /i) {
        $data->{gig} = $1;
    } elsif ($t =~ m/ (\d+) tb /i) {
        $data->{gig} = $1 * 1000;
    } elsif ($t =~ m/ ([0-9][0-9.]+)tb /i) {
        $data->{gig} = $1 * 1000;
    }

    if ($t =~ m/seagate /i) {
        $data->{brand} = 'Seagate';
    } elsif ($t =~ m/toshiba /i) {
        $data->{brand} = 'Toshiba';
    } elsif ($t =~ m/samsung /i) {
        $data->{brand} = 'Samsung';
    } elsif ($t =~ m/crucial /i) {
        $data->{brand} = 'Crucial';
    } elsif ($t =~ m/sandisk /i) {
        $data->{brand} = 'SanDisk';
    } elsif ($t =~ m/hitachi /i) {
        $data->{brand} = 'Hitachi';
    } elsif ($t =~ m/kingston /i) {
        $data->{brand} = 'Kingston';
    } elsif ($t =~ m/micron /i) {
        $data->{brand} = 'Micron';
    } elsif ($t =~ m/qnap /i) {
        $data->{brand} = 'Qnap';
    } elsif ($t =~ m/intel /i) {
        $data->{brand} = 'Intel';
    } elsif ($t =~ m/adata /i) {
        $data->{brand} = 'Adata';
    } elsif ($t =~ m/gigabyte /i) {
        $data->{brand} = 'Gigabyte';
    } elsif ($t =~ m/team /i) {
        $data->{brand} = 'Team';
    } elsif ($t =~ m/hp /i) {
        $data->{brand} = 'HP';
    } elsif ($t =~ m/wd /i) {
        $data->{brand} = 'WD';
    }

    if ($t =~ m/nvme /i) {
        $data->{interface} = 'NVME';
    } elsif ($t =~ m/SAS /i) {
        $data->{interface} = 'SAS';
    }

    # TODO - ensure price starts with a dollarsign
    $data->{date} = 'FIXME';
    $data->{supplier} = 'CPL';

    if ($data->{price} && $data->{gig}) {
        $data->{sgig} = $data->{price} / $data->{gig};
    }

    # Set some default values
    default($data,'brand','?');
    default($data,'form','?');
    default($data,'gig','?');
    default($data,'interface','?');
    default($data,'rpm','?');
    default($data,'sgig','?');

    # commas annoy my dodgy not-quite-csv
    $data->{comment} =~ s/,/_/g;

    return $data;
}

sub normaliseproducts {
    my @products;
    while (my $prod = shift) {
        push @products, normalise1product($prod);
    }
    return @products;
}

sub scrape1product {
    my $node = shift;
    my $data = {};

    my $url = $node->look_down('_tag', 'a');
    if (!$url) {
        warn("Could not find product image and url");
        return undef;
    }

    $data->{comment} = $url->attr('title');
    $data->{url} = $url->attr('href');
    
    my $price = $node->look_down('_tag', 'span', 'class', 'price');
    if (!$price) {
        warn("Could not find price");
        return undef;
    }

    $data->{price} = $price->as_trimmed_text();

    return $data;
}

sub scrape2products {
    my $tree = shift;

    my $products = $tree->look_down(
        '_tag', 'div',
        'class', 'category-products',
    );
    if (!$products) {
        warn("Could not find products");
        return undef;
    }

    my @products;
    for my $node ($products->look_down(
            '_tag', 'li',
            'class', qr/item/,
        )) {
        push @products, scrape1product($node);
    }

    return @products;
}

my @products;
for my $file (@ARGV) {
    my $tree = file2tree($file);
    push @products, scrape2products($tree);
}

@products = normaliseproducts(@products);

my @fields = qw(date price form interface rpm gig sgig brand supplier comment);

print(join(',', @fields), "\n");

for my $prod (@products) {
    print(join(',', map({$prod->{$_}} @fields)), "\n");
}

#print Dumper(@products);

